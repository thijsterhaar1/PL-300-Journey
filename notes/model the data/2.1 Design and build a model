### Step 1 – Star schema (fact vs dimension tables)

#### What I did in Power BI
- Opened my model in **Model view**.
- Reviewed each table to decide if it is:
  - A **fact table** (transactional, many rows, contains numeric measures).
  - A **dimension table** (descriptive attributes like Customer, Product, Date, Region).
- Identified my main fact table:
  - `FactSales` (one row per **order line** – this is the grain).
- Identified key dimension tables:
  - `DimCustomer`, `DimProduct`, `DimDate`, `DimStore`, ...
- Arranged the model visually as a **star**:
  - Fact table in the center.
  - Dimension tables around it like star points.

#### What I learned
- A **fact table** stores events/transactions at a specific grain (e.g. one row per order line).
- A **dimension table** stores descriptive attributes used to filter, group, and slice facts.
- A **star schema** = one central fact table with multiple dimension tables directly connected to it.
- Star schemas are:
  - Easier for users to understand.
  - Better for performance and simpler DAX than complex/snowflake models.
- Clearly defining the **grain** of the fact table is important to avoid confusion in measures.

---

### Step 2 – Identify keys for relationships

#### What I did in Power BI
- Loaded the CSV files:
  - DimCustomer, DimProduct, DimStore, DimDate, FactSales.
- In Power Query, turned on:
  - Column quality
  - Column distribution
  - Column profile
  - Profiling based on **Entire data**.
- Checked primary keys in dimension tables:
  - `DimCustomer[CustomerID]` → unique, no nulls.
  - `DimProduct[ProductID]` → unique, no nulls.
  - `DimStore[StoreID]` → unique, no nulls.
  - `DimDate[DateKey]` → unique, no nulls.
- Checked keys in the fact table:
  - `FactSales[SalesID]` → unique → primary key of the fact table.
  - `FactSales[CustomerID]`, `[ProductID]`, `[StoreID]`, `[DateKey]`:
    - Many repeated values, no nulls → good foreign keys.
- Created a conceptual mapping:
  - DimCustomer[CustomerID] → FactSales[CustomerID]
  - DimProduct[ProductID] → FactSales[ProductID]
  - DimStore[StoreID] → FactSales[StoreID]
  - DimDate[DateKey] → FactSales[DateKey]

#### What I learned
- A **primary key** uniquely identifies each row in a table and should have no null values.
- In a star schema, dimension tables usually provide the primary keys used in relationships.
- A **foreign key** is a column in another table that refers to a primary key.
- In the fact table:
  - Foreign keys can repeat many times (one customer/product appears in many sales).
  - A separate surrogate key (SalesID) can be used as the fact table's primary key.
- Clearly identifying primary and foreign keys makes it easier to create correct relationships in the model.

---

### Step 3 – Create relationships between tables

#### What I did in Power BI
- Opened **Model view** with:
  - DimCustomer, DimProduct, DimStore, DimDate, FactSales.
- Removed any incorrect auto-detected relationships.
- Manually created relationships:
  - DimCustomer[CustomerID] → FactSales[CustomerID]
  - DimProduct[ProductID] → FactSales[ProductID]
  - DimStore[StoreID] → FactSales[StoreID]
  - DimDate[DateKey] → FactSales[DateKey]
- Checked each relationship:
  - Dimension table on the **1** side, FactSales on the **\*** side.
  - Cross filter direction set to **Single**.
  - Relationship marked as **Active**.
- Tested with a simple report:
  - Table visual with CustomerName and SalesAmount to confirm filters work.

#### What I learned
- Relationships in a star schema connect each dimension key to its matching foreign key in the fact table.
- Creating relationships manually gives more control than relying on auto-detect.
- Having the correct relationships is required for filters and measures to work correctly in reports.

---

### Step 4 – Relationship cardinality

#### What I did in Power BI
- Opened **Model view** and checked all relationships:
  - DimCustomer → FactSales
  - DimProduct → FactSales
  - DimStore → FactSales
  - DimDate → FactSales
- For each relationship, confirmed:
  - The **dimension** table is on the "1" side.
  - The **fact** table (FactSales) is on the "*" side.
  - Cardinality shows as "Many to one (*:1)" from fact to dimension,
    which conceptually is a **1:* (one-to-many)** relationship.

#### What I learned
- **One-to-many (1:*)**:
  - Most common in star schemas.
  - Dimension table has unique keys (1 side).
  - Fact table has many matching rows (* side).
- **Many-to-many (*:*)**:
  - Both tables have repeated key values.
  - Can lead to ambiguous filters and double counting.
  - Should be used carefully, often with a bridge table.
- **One-to-one (1:1)**:
  - Less common.
  - Used when two tables share a unique key and could almost be a single table.
- Best practice:
  - Design star schemas so dimensions are on the **1** side
    and the fact table is on the **\*** side (one-to-many).
  - Avoid many-to-many unless there is a clear reason and design.

---

### Step 5 – Cross filter direction (Single vs Both)

#### What I did in Power BI
- Opened **Model view → Manage relationships**.
- For all relationships:
  - Confirmed **Cross filter direction = Single**.
  - Dimension tables filter FactSales, not the other way around.
- (Optional test)
  - Temporarily changed one relationship to **Both** to see how filters propagate further through the model.
  - Switched it back to **Single** to keep a clean star schema.

#### What I learned
- **Single** cross filter direction:
  - Filters flow from the "1" side (dimension) to the "*" side (fact).
  - This is the **recommended default** for star schemas.
- **Both** cross filter direction:
  - Filters can flow in both directions.
  - Can be useful in special scenarios (e.g., when two dimensions need to filter each other via a fact).
  - Increases risk of ambiguous relationships and unexpected filter behavior.
- Best practice for PL-300:
  - Use **Single** for dimension → fact in a star schema.
  - Use **Both** only when there is a clear, justified scenario and you understand the impact.
