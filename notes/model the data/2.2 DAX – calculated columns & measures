### Step 1 – Calculated column vs measure

#### What I did in Power BI
- Created a **calculated column** in fact_sales:

  `SalesAmount Calc Column = fact_sales[Quantity] * fact_sales[UnitPrice]`

  - Value stored per row in the table.
  - Does not change when I filter the report.

- Created a **measure**:

  `Total Sales = SUM(fact_sales[SalesAmount])`

  - Used the measure in a table visual with CustomerName.
  - Saw that the measure result changes depending on filters and slicers.

#### What I learned
- **Calculated column**
  - Evaluated when the data is loaded/refreshes.
  - Stores a value **per row** in the table.
  - Increases model size because values are saved.
  - Useful when I need the value as:
    - A grouping/slicer/axis
    - Part of relationships or row-level security.

- **Measure**
  - Not stored in the table; calculated **on the fly**.
  - Uses the current **filter context** (what the user has filtered).
  - Ideal for aggregations (SUM, AVERAGE, counts, ratios).
  - Best for KPIs and numbers shown in visuals.

- Rule of thumb:
  - If I need a value per row (for grouping, filtering, or relationships) → **calculated column**.
  - If I just need a number in visuals that should react to filters → **measure**.

---

### Step 2 – Create basic calculated columns

#### What I did in Power BI
- Created a **Quantity Category** column in `fact_sales`:

  `Quantity Category = IF( fact_sales[Quantity] >= 3, "High", "Low" )`

- Created a **YearMonth** column in `dim_date`:

  `YearMonth = FORMAT( dim_date[Date], "YYYY-MM" )`

- Created a **Customer Label** column in `dim_customer`:

  `Customer Label = dim_customer[CustomerName] & " (" & dim_customer[City] & ")"`

- Used these columns in visuals as slicers/axes/labels.

#### What I learned
- Calculated columns are evaluated row by row and stored in the model.
- They are useful for:
  - Grouping (e.g. High/Low categories),
  - Creating friendly labels,
  - Building date/grouping fields like Year-Month.
- DAX operators (arithmetic, comparison, text concatenation) are the basics for most calculated columns.

---

### Step 3 – Create basic measures (SUM, COUNT, COUNTROWS, AVERAGE)

#### What I did in Power BI
- Created SUM measures:
  - `Total Sales = SUM( fact_sales[SalesAmount] )`
  - `Total Quantity = SUM( fact_sales[Quantity] )`
- Created count measures:
  - `Order Count (COUNT) = COUNT( fact_sales[SalesID] )`
  - `Order Count (COUNTROWS) = COUNTROWS( fact_sales )`
- Created an average measure:
  - `Average Quantity per Order = AVERAGE( fact_sales[Quantity] )`
- Used these measures in:
  - Card visuals for totals.
  - Table visuals with CustomerName / StoreName to see values per group.
  - Slicers to see how measures react to filters.

#### What I learned
- **SUM(column)** adds up all numeric values in the column (respecting filters).
- **COUNT(column)** counts non-blank values in a single column.
- **COUNTROWS(table)** counts all rows in the table for the current filter context.
- **AVERAGE(column)** returns the average of a numeric column.
- Measures:
  - Are not stored in the table.
  - Are recalculated dynamically based on the current filters in the report.

---

### Step 4 – Use CALCULATE to change filter context

#### What I did in Power BI
- Created measure **Total Sales Corporate**:

  `Total Sales Corporate =
  CALCULATE(
      [Total Sales],
      dim_customer[Segment] = "Corporate"
  )`

  - Always returns sales for Corporate customers only, even when other segments are selected.

- Created measure **Total Sales All Customers**:

  `Total Sales All Customers =
  CALCULATE(
      [Total Sales],
      ALL( dim_customer )
  )`

  - Ignores any filters on the Customer dimension.

- Tested in visuals:
  - Card for `Total Sales Corporate` with various slicers.
  - Table with CustomerName, `Total Sales`, and `Total Sales All Customers` to see the difference.

#### What I learned
- `CALCULATE` reevaluates a measure in a **modified filter context**.
- Extra filter arguments like `dim_customer[Segment] = "Corporate"` add/override filters.
- Using `ALL(dim_customer)` removes filters from that table (useful for "ignore slicer" scenarios).
- `CALCULATE` is the main function to control *how* and *for whom* a measure is calculated.

---

### Step 5 – Use FILTER in a measure

#### What I did in Power BI
- Created a measure to calculate sales from high-quantity orders:

  Total Sales High Qty =
  CALCULATE(
      [Total Sales],
      FILTER(
          fact_sales,
          fact_sales[Quantity] >= 3
      )
  )

- Used this measure in:
  - Card visuals (compare Total Sales vs. Total Sales High Qty).
  - Table visual with CustomerName to see high-quantity sales per customer.

#### What I learned
- `FILTER(table, condition)` returns a **table** with only rows that meet the condition.
- `CALCULATE` uses that filtered table to **change the filter context** of a measure.
- Use `FILTER` when:
  - De voorwaarde per rij wordt bepaald (bijv. Quantity >= 3),
  - Of als de logica te complex is voor een simpele `column = value` filter in CALCULATE.

---

### Step 6 – Use RELATED / RELATEDTABLE

#### What I did in Power BI
- Created a calculated column in `fact_sales`:

  Customer Segment =
  RELATED( dim_customer[Segment] )

  - Brings the customer segment from DimCustomer into each sales row.

- Created a measure in `dim_customer`:

  Sales Count per Customer =
  COUNTROWS( RELATEDTABLE( fact_sales ) )

  - Counts how many FactSales rows are related to each customer.

- Used these in visuals:
  - Table with CustomerName, Customer Segment, Sales Count per Customer, and Total Sales.

#### What I learned
- **RELATED(column)**:
  - Works in row context (e.g. calculated columns).
  - Follows an existing relationship to fetch a single value from the *related* table.
  - Typisch: van **fact** naar **dimension** (many → one).

- **RELATEDTABLE(table)**:
  - Returns a table with all related rows.
  - Vaak gebruikt in combinatie met aggregaties zoals `COUNTROWS`, `SUMX`, etc.
  - Typisch: van **dimension** naar **fact** (one → many).

- These functions rely on relationships in the model:
  - If the relationship is missing or inactive, `RELATED` / `RELATEDTABLE` will not work.

---

